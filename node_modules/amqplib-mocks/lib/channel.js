"use strict";

let routeMessages = (() => {
	var _ref = _asyncToGenerator(function* (consumers, message) {
		yield Promise.all(_.map(consumers, (() => {
			var _ref2 = _asyncToGenerator(function* (handler) {
				return handler(message);
			});

			return function (_x3) {
				return _ref2.apply(this, arguments);
			};
		})()));
		return true;
	});

	return function routeMessages(_x, _x2) {
		return _ref.apply(this, arguments);
	};
})();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/* eslint-disable max-lines */
const _ = require("lodash");
const shortid = require("shortid");
const sinon = require("sinon");

function setIfUndefined(object, prop, value) {
	if (!object[prop]) {
		object[prop] = value;
	}
}

function findHandlers(connection, exchange, routingKey) {
	if (!exchange) {
		return {};
	}

	const filtered = _.filter(exchange.bindings, binding => binding.regex.test(routingKey));
	return _.transform(filtered, (result, binding) => {
		if (binding.queueName) {
			const queue = connection.queues[binding.queueName];
			return Object.assign(result, queue.consumers || {});
		}
		if (binding.exchangeName) {
			const boundExchange = connection.exchanges[binding.exchangeName];
			const consumers = findHandlers(connection, boundExchange, routingKey);
			return Object.assign(result, consumers || {});
		}
		return false;
	}, {});
}

function generateBindingRegex(pattern) {
	pattern = (pattern || "#").replace(".", "\\.").replace("#", "(\\w|\\.)+").replace("*", "\\w+");
	return new RegExp(`^${pattern}$`);
}

class Channel {
	constructor(connection) {
		var _this = this;

		this.connection = connection;

		this.ack = sinon.stub();
		this.nack = sinon.stub();
		this.reject = sinon.stub();
		this.prefetch = sinon.stub();
		this.on = sinon.stub();
		this.once = sinon.stub();

		this.trackedMessages = [];

		this.assertQueue = sinon.stub().callsFake((() => {
			var _ref3 = _asyncToGenerator(function* (queue, opt) {
				setIfUndefined(_this.connection.queues, queue, { messages: [], consumers: {}, options: opt });
				return { queue, messageCount: 0, consumerCount: 0 };
			});

			return function (_x4, _x5) {
				return _ref3.apply(this, arguments);
			};
		})());

		this.assertExchange = sinon.stub().callsFake((() => {
			var _ref4 = _asyncToGenerator(function* (exchange, opt) {
				setIfUndefined(_this.connection.exchanges, exchange, { bindings: [], options: opt });
				return { exchange };
			});

			return function (_x6, _x7) {
				return _ref4.apply(this, arguments);
			};
		})());

		this.bindExchange = sinon.stub().callsFake((() => {
			var _ref5 = _asyncToGenerator(function* (destination, source, pattern, args) {
				if (!_this.connection.exchanges[source]) {
					throw new Error(`Bind to non-existing exchange: ${source}`);
				}
				const regex = generateBindingRegex(pattern);
				_this.connection.exchanges[source].bindings.push({ regex, exchangeName: destination });
				return {};
			});

			return function (_x8, _x9, _x10, _x11) {
				return _ref5.apply(this, arguments);
			};
		})());

		this.bindQueue = sinon.stub().callsFake((() => {
			var _ref6 = _asyncToGenerator(function* (queue, exchange, pattern, args) {
				if (!_this.connection.exchanges[exchange]) {
					throw new Error(`Bind to non-existing exchange: ${exchange}`);
				}
				const regex = generateBindingRegex(pattern);
				_this.connection.exchanges[exchange].bindings.push({ regex, queueName: queue });
				return {};
			});

			return function (_x12, _x13, _x14, _x15) {
				return _ref6.apply(this, arguments);
			};
		})());

		this.consume = sinon.stub().callsFake((() => {
			var _ref7 = _asyncToGenerator(function* (queueName, handler) {
				const queue = _this.connection.queues[queueName];
				if (!queue) {
					throw new Error(`Consuming from non-existing queue: ${queueName}`);
				}
				const consumerTag = shortid.generate();
				queue.consumers[consumerTag] = handler;
				return { consumerTag };
			});

			return function (_x16, _x17) {
				return _ref7.apply(this, arguments);
			};
		})());

		this.publish = sinon.stub().callsFake((() => {
			var _ref8 = _asyncToGenerator(function* (exchangeName, routingKey, content, properties) {
				const exchange = _this.connection.exchanges[exchangeName];
				if (!exchange) {
					throw new Error(`Publish to non-existing exchange: ${exchangeName}`);
				}
				const consumers = findHandlers(_this.connection, exchange, routingKey);
				const message = { fields: { routingKey, exchange: exchangeName }, content, properties };
				_this.trackedMessages.push(message);
				return routeMessages(consumers, message);
			});

			return function (_x18, _x19, _x20, _x21) {
				return _ref8.apply(this, arguments);
			};
		})());

		this.sendToQueue = sinon.stub().callsFake((() => {
			var _ref9 = _asyncToGenerator(function* (queueName, content, properties) {
				const queue = _this.connection.queues[queueName];
				if (!queue) {
					return true;
				}
				const message = { fields: { routingKey: queueName }, content, properties };
				_this.trackedMessages.push(message);
				return routeMessages(queue.consumers, message);
			});

			return function (_x22, _x23, _x24) {
				return _ref9.apply(this, arguments);
			};
		})());
	}

	// amqplib sends a null message when it receives a close event from Rabbit
	closeConsumer(queueName) {
		var _this2 = this;

		return _asyncToGenerator(function* () {
			const queue = _this2.connection.queues[queueName];
			if (!queue) {
				return true;
			}
			return routeMessages(queue.consumers, null);
		})();
	}
}

module.exports = Channel;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jaGFubmVsLmpzIl0sIm5hbWVzIjpbImNvbnN1bWVycyIsIm1lc3NhZ2UiLCJQcm9taXNlIiwiYWxsIiwiXyIsIm1hcCIsImhhbmRsZXIiLCJyb3V0ZU1lc3NhZ2VzIiwicmVxdWlyZSIsInNob3J0aWQiLCJzaW5vbiIsInNldElmVW5kZWZpbmVkIiwib2JqZWN0IiwicHJvcCIsInZhbHVlIiwiZmluZEhhbmRsZXJzIiwiY29ubmVjdGlvbiIsImV4Y2hhbmdlIiwicm91dGluZ0tleSIsImZpbHRlcmVkIiwiZmlsdGVyIiwiYmluZGluZ3MiLCJiaW5kaW5nIiwicmVnZXgiLCJ0ZXN0IiwidHJhbnNmb3JtIiwicmVzdWx0IiwicXVldWVOYW1lIiwicXVldWUiLCJxdWV1ZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJleGNoYW5nZU5hbWUiLCJib3VuZEV4Y2hhbmdlIiwiZXhjaGFuZ2VzIiwiZ2VuZXJhdGVCaW5kaW5nUmVnZXgiLCJwYXR0ZXJuIiwicmVwbGFjZSIsIlJlZ0V4cCIsIkNoYW5uZWwiLCJjb25zdHJ1Y3RvciIsImFjayIsInN0dWIiLCJuYWNrIiwicmVqZWN0IiwicHJlZmV0Y2giLCJvbiIsIm9uY2UiLCJ0cmFja2VkTWVzc2FnZXMiLCJhc3NlcnRRdWV1ZSIsImNhbGxzRmFrZSIsIm9wdCIsIm1lc3NhZ2VzIiwib3B0aW9ucyIsIm1lc3NhZ2VDb3VudCIsImNvbnN1bWVyQ291bnQiLCJhc3NlcnRFeGNoYW5nZSIsImJpbmRFeGNoYW5nZSIsImRlc3RpbmF0aW9uIiwic291cmNlIiwiYXJncyIsIkVycm9yIiwicHVzaCIsImJpbmRRdWV1ZSIsImNvbnN1bWUiLCJjb25zdW1lclRhZyIsImdlbmVyYXRlIiwicHVibGlzaCIsImNvbnRlbnQiLCJwcm9wZXJ0aWVzIiwiZmllbGRzIiwic2VuZFRvUXVldWUiLCJjbG9zZUNvbnN1bWVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7OzhCQStCQSxXQUE4QkEsU0FBOUIsRUFB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QVA7QUFDQSxJQVJrQjs7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFuQjtBQVNBOztBQUVEO0FBQ011RSxjQUFOLENBQXFCN0MsU0FBckIsRUFBaUM7QUFBQTs7QUFBQTtBQUNoQyxTQUFNQyxRQUFRLE9BQUtaLFVBQUwsQ0FBZ0JhLE1BQWhCLENBQXdCRixTQUF4QixDQUFkO0FBQ0EsT0FBSyxDQUFDQyxLQUFOLEVBQWM7QUFDYixXQUFPLElBQVA7QUFDQTtBQUNELFVBQU9yQixjQUFlcUIsTUFBTTVCLFNBQXJCLEVBQWdDLElBQWhDLENBQVA7QUFMZ0M7QUFNaEM7QUFoRlk7O0FBbUZkeUUsT0FBT0MsT0FBUCxHQUFpQm5DLE9BQWpCIiwiZmlsZSI6ImNoYW5uZWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGluZXMgKi9cbmNvbnN0IF8gPSByZXF1aXJlKCBcImxvZGFzaFwiICk7XG5jb25zdCBzaG9ydGlkID0gcmVxdWlyZSggXCJzaG9ydGlkXCIgKTtcbmNvbnN0IHNpbm9uID0gcmVxdWlyZSggXCJzaW5vblwiICk7XG5cbmZ1bmN0aW9uIHNldElmVW5kZWZpbmVkKCBvYmplY3QsIHByb3AsIHZhbHVlICkge1xuXHRpZiAoICFvYmplY3RbIHByb3AgXSApIHtcblx0XHRvYmplY3RbIHByb3AgXSA9IHZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGZpbmRIYW5kbGVycyggY29ubmVjdGlvbiwgZXhjaGFuZ2UsIHJvdXRpbmdLZXkgKSB7XG5cdGlmICggIWV4Y2hhbmdlICkge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdGNvbnN0IGZpbHRlcmVkID0gXy5maWx0ZXIoIGV4Y2hhbmdlLmJpbmRpbmdzLCBiaW5kaW5nID0+IGJpbmRpbmcucmVnZXgudGVzdCggcm91dGluZ0tleSApICk7XG5cdHJldHVybiBfLnRyYW5zZm9ybSggZmlsdGVyZWQsICggcmVzdWx0LCBiaW5kaW5nICkgPT4ge1xuXHRcdGlmICggYmluZGluZy5xdWV1ZU5hbWUgKSB7XG5cdFx0XHRjb25zdCBxdWV1ZSA9IGNvbm5lY3Rpb24ucXVldWVzWyBiaW5kaW5nLnF1ZXVlTmFtZSBdO1xuXHRcdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oIHJlc3VsdCwgcXVldWUuY29uc3VtZXJzIHx8IHt9ICk7XG5cdFx0fVxuXHRcdGlmICggYmluZGluZy5leGNoYW5nZU5hbWUgKSB7XG5cdFx0XHRjb25zdCBib3VuZEV4Y2hhbmdlID0gY29ubmVjdGlvbi5leGNoYW5nZXNbIGJpbmRpbmcuZXhjaGFuZ2VOYW1lIF07XG5cdFx0XHRjb25zdCBjb25zdW1lcnMgPSBmaW5kSGFuZGxlcnMoIGNvbm5lY3Rpb24sIGJvdW5kRXhjaGFuZ2UsIHJvdXRpbmdLZXkgKTtcblx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduKCByZXN1bHQsIGNvbnN1bWVycyB8fCB7fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sIHt9ICk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJvdXRlTWVzc2FnZXMoIGNvbnN1bWVycywgbWVzc2FnZSApIHtcblx0YXdhaXQgUHJvbWlzZS5hbGwoIF8ubWFwKCBjb25zdW1lcnMsIGFzeW5jIGhhbmRsZXIgPT4ge1xuXHRcdHJldHVybiBoYW5kbGVyKCBtZXNzYWdlICk7XG5cdH0gKSApO1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCaW5kaW5nUmVnZXgoIHBhdHRlcm4gKSB7XG5cdHBhdHRlcm4gPSAoIHBhdHRlcm4gfHwgXCIjXCIgKVxuXHRcdC5yZXBsYWNlKCBcIi5cIiwgXCJcXFxcLlwiIClcblx0XHQucmVwbGFjZSggXCIjXCIsIFwiKFxcXFx3fFxcXFwuKStcIiApXG5cdFx0LnJlcGxhY2UoIFwiKlwiLCBcIlxcXFx3K1wiICk7XG5cdHJldHVybiBuZXcgUmVnRXhwKCBgXiR7IHBhdHRlcm4gfSRgICk7XG59XG5cbmNsYXNzIENoYW5uZWwge1xuXHRjb25zdHJ1Y3RvciggY29ubmVjdGlvbiApIHtcblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuXG5cdFx0dGhpcy5hY2sgPSBzaW5vbi5zdHViKCk7XG5cdFx0dGhpcy5uYWNrID0gc2lub24uc3R1YigpO1xuXHRcdHRoaXMucmVqZWN0ID0gc2lub24uc3R1YigpO1xuXHRcdHRoaXMucHJlZmV0Y2ggPSBzaW5vbi5zdHViKCk7XG5cdFx0dGhpcy5vbiA9IHNpbm9uLnN0dWIoKTtcblx0XHR0aGlzLm9uY2UgPSBzaW5vbi5zdHViKCk7XG5cblx0XHR0aGlzLnRyYWNrZWRNZXNzYWdlcyA9IFtdO1xuXG5cdFx0dGhpcy5hc3NlcnRRdWV1ZSA9IHNpbm9uLnN0dWIoKS5jYWxsc0Zha2UoIGFzeW5jICggcXVldWUsIG9wdCApID0+IHtcblx0XHRcdHNldElmVW5kZWZpbmVkKCB0aGlzLmNvbm5lY3Rpb24ucXVldWVzLCBxdWV1ZSwgeyBtZXNzYWdlczogW10sIGNvbnN1bWVyczoge30sIG9wdGlvbnM6IG9wdCB9ICk7XG5cdFx0XHRyZXR1cm4geyBxdWV1ZSwgbWVzc2FnZUNvdW50OiAwLCBjb25zdW1lckNvdW50OiAwIH07XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5hc3NlcnRFeGNoYW5nZSA9IHNpbm9uLnN0dWIoKS5jYWxsc0Zha2UoIGFzeW5jICggZXhjaGFuZ2UsIG9wdCApID0+IHtcblx0XHRcdHNldElmVW5kZWZpbmVkKCB0aGlzLmNvbm5lY3Rpb24uZXhjaGFuZ2VzLCBleGNoYW5nZSwgeyBiaW5kaW5nczogW10sIG9wdGlvbnM6IG9wdCB9ICk7XG5cdFx0XHRyZXR1cm4geyBleGNoYW5nZSB9O1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuYmluZEV4Y2hhbmdlID0gc2lub24uc3R1YigpLmNhbGxzRmFrZSggYXN5bmMgKCBkZXN0aW5hdGlvbiwgc291cmNlLCBwYXR0ZXJuLCBhcmdzICkgPT4ge1xuXHRcdFx0aWYgKCAhdGhpcy5jb25uZWN0aW9uLmV4Y2hhbmdlc1sgc291cmNlIF0gKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYEJpbmQgdG8gbm9uLWV4aXN0aW5nIGV4Y2hhbmdlOiAkeyBzb3VyY2UgfWAgKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHJlZ2V4ID0gZ2VuZXJhdGVCaW5kaW5nUmVnZXgoIHBhdHRlcm4gKTtcblx0XHRcdHRoaXMuY29ubmVjdGlvbi5leGNoYW5nZXNbIHNvdXJjZSBdLmJpbmRpbmdzLnB1c2goIHsgcmVnZXgsIGV4Y2hhbmdlTmFtZTogZGVzdGluYXRpb24gfSApO1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuYmluZFF1ZXVlID0gc2lub24uc3R1YigpLmNhbGxzRmFrZSggYXN5bmMgKCBxdWV1ZSwgZXhjaGFuZ2UsIHBhdHRlcm4sIGFyZ3MgKSA9PiB7XG5cdFx0XHRpZiAoICF0aGlzLmNvbm5lY3Rpb24uZXhjaGFuZ2VzWyBleGNoYW5nZSBdICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBCaW5kIHRvIG5vbi1leGlzdGluZyBleGNoYW5nZTogJHsgZXhjaGFuZ2UgfWAgKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHJlZ2V4ID0gZ2VuZXJhdGVCaW5kaW5nUmVnZXgoIHBhdHRlcm4gKTtcblx0XHRcdHRoaXMuY29ubmVjdGlvbi5leGNoYW5nZXNbIGV4Y2hhbmdlIF0uYmluZGluZ3MucHVzaCggeyByZWdleCwgcXVldWVOYW1lOiBxdWV1ZSB9ICk7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5jb25zdW1lID0gc2lub24uc3R1YigpLmNhbGxzRmFrZSggYXN5bmMgKCBxdWV1ZU5hbWUsIGhhbmRsZXIgKSA9PiB7XG5cdFx0XHRjb25zdCBxdWV1ZSA9IHRoaXMuY29ubmVjdGlvbi5xdWV1ZXNbIHF1ZXVlTmFtZSBdO1xuXHRcdFx0aWYgKCAhcXVldWUgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYENvbnN1bWluZyBmcm9tIG5vbi1leGlzdGluZyBxdWV1ZTogJHsgcXVldWVOYW1lIH1gICk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjb25zdW1lclRhZyA9IHNob3J0aWQuZ2VuZXJhdGUoKTtcblx0XHRcdHF1ZXVlLmNvbnN1bWVyc1sgY29uc3VtZXJUYWcgXSA9IGhhbmRsZXI7XG5cdFx0XHRyZXR1cm4geyBjb25zdW1lclRhZyB9O1xuXHRcdH0gKTtcblxuXHRcdHRoaXMucHVibGlzaCA9IHNpbm9uLnN0dWIoKS5jYWxsc0Zha2UoIGFzeW5jICggZXhjaGFuZ2VOYW1lLCByb3V0aW5nS2V5LCBjb250ZW50LCBwcm9wZXJ0aWVzICkgPT4ge1xuXHRcdFx0Y29uc3QgZXhjaGFuZ2UgPSB0aGlzLmNvbm5lY3Rpb24uZXhjaGFuZ2VzWyBleGNoYW5nZU5hbWUgXTtcblx0XHRcdGlmICggIWV4Y2hhbmdlICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBQdWJsaXNoIHRvIG5vbi1leGlzdGluZyBleGNoYW5nZTogJHsgZXhjaGFuZ2VOYW1lIH1gICk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjb25zdW1lcnMgPSBmaW5kSGFuZGxlcnMoIHRoaXMuY29ubmVjdGlvbiwgZXhjaGFuZ2UsIHJvdXRpbmdLZXkgKTtcblx0XHRcdGNvbnN0IG1lc3NhZ2UgPSB7IGZpZWxkczogeyByb3V0aW5nS2V5LCBleGNoYW5nZTogZXhjaGFuZ2VOYW1lIH0sIGNvbnRlbnQsIHByb3BlcnRpZXMgfTtcblx0XHRcdHRoaXMudHJhY2tlZE1lc3NhZ2VzLnB1c2goIG1lc3NhZ2UgKTtcblx0XHRcdHJldHVybiByb3V0ZU1lc3NhZ2VzKCBjb25zdW1lcnMsIG1lc3NhZ2UgKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLnNlbmRUb1F1ZXVlID0gc2lub24uc3R1YigpLmNhbGxzRmFrZSggYXN5bmMgKCBxdWV1ZU5hbWUsIGNvbnRlbnQsIHByb3BlcnRpZXMgKSA9PiB7XG5cdFx0XHRjb25zdCBxdWV1ZSA9IHRoaXMuY29ubmVjdGlvbi5xdWV1ZXNbIHF1ZXVlTmFtZSBdO1xuXHRcdFx0aWYgKCAhcXVldWUgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IHsgZmllbGRzOiB7IHJvdXRpbmdLZXk6IHF1ZXVlTmFtZSB9LCBjb250ZW50LCBwcm9wZXJ0aWVzIH07XG5cdFx0XHR0aGlzLnRyYWNrZWRNZXNzYWdlcy5wdXNoKCBtZXNzYWdlICk7XG5cdFx0XHRyZXR1cm4gcm91dGVNZXNzYWdlcyggcXVldWUuY29uc3VtZXJzLCBtZXNzYWdlICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gYW1xcGxpYiBzZW5kcyBhIG51bGwgbWVzc2FnZSB3aGVuIGl0IHJlY2VpdmVzIGEgY2xvc2UgZXZlbnQgZnJvbSBSYWJiaXRcblx0YXN5bmMgY2xvc2VDb25zdW1lciggcXVldWVOYW1lICkge1xuXHRcdGNvbnN0IHF1ZXVlID0gdGhpcy5jb25uZWN0aW9uLnF1ZXVlc1sgcXVldWVOYW1lIF07XG5cdFx0aWYgKCAhcXVldWUgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJvdXRlTWVzc2FnZXMoIHF1ZXVlLmNvbnN1bWVycywgbnVsbCApO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbm5lbDtcbiJdfQ==