"use strict";

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const _ = require("lodash");
const sinon = require("sinon");
const Channel = require("./channel");

class Connection {
	constructor(onClose) {
		this.queues = {};
		this.exchanges = {};
		this.on = sinon.stub();

		this.createChannel = sinon.stub().callsFake(() => {
			return this.channel = new Channel(this);
		});

		this.createConfirmChannel = sinon.stub().callsFake(() => {
			return this.channel = new Channel(this);
		});

		this.close = sinon.stub().callsFake(() => {
			onClose();
			this.on.withArgs("close").yield();
		});
	}

	// Test Helpers

	get currentChannel() {
		return this.channel;
	}

	get trackedMessages() {
		return this.channel.trackedMessages;
	}

	sendUntracked(queueName, content, properties) {
		var _this = this;

		return _asyncToGenerator(function* () {
			const channel = new Channel(_this);
			yield channel.sendToQueue(queueName, content, properties);
		})();
	}

	publishUntracked(exchange, routingKey, content, properties) {
		var _this2 = this;

		return _asyncToGenerator(function* () {
			const channel = new Channel(_this2);
			yield channel.publish(exchange, routingKey, content, properties);
		})();
	}

	getPublished({ filter = _.stubTrue, bodyTransform = _.identity }) {
		return this.channel.trackedMessages.filter(msg => filter(msg)).map(msg => Object.assign(msg, { body: bodyTransform(msg.content) }));
	}
}

module.exports = Connection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25uZWN0aW9uLmpzIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwic2lub24iLCJDaGFubmVsIiwiQ29ubmVjdGlvbiIsImNvbnN0cnVjdG9yIiwib25DbG9zZSIsInF1ZXVlcyIsImV4Y2hhbmdlcyIsIm9uIiwic3R1YiIsImNyZWF0ZUNoYW5uZWwiLCJjYWxsc0Zha2UiLCJjaGFubmVsIiwiY3JlYXRlQ29uZmlybUNoYW5uZWwiLCJjbG9zZSIsIndpdGhBcmdzIiwieWllbGQiLCJjdXJyZW50Q2hhbm5lbCIsInRyYWNrZWRNZXNzYWdlcyIsInNlbmRVbnRyYWNrZWQiLCJxdWV1ZU5hbWUiLCJjb250ZW50IiwicHJvcGVydGllcyIsInNlbmRUb1F1ZXVlIiwicHVibGlzaFVudHJhY2tlZCIsImV4Y2hhbmdlIiwicm91dGluZ0tleSIsInB1Ymxpc2giLCJnZXRQdWJsaXNoZWQiLCJmaWx0ZXIiLCJzdHViVHJ1ZSIsImJvZHlUcmFuc2Zvcm0iLCJpZGVudGl0eSIsIm1zZyIsIm1hcCIsIk9iamVjdCIsImFzc2lnbiIsImJvZHkiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsSUFBSUMsUUFBUyxRQUFULENBQVY7QUFDQSxNQUFNQyxRQUFRRCxRQUFTLE9BQVQsQ0FBZDtBQUNBLE1BQU1FLFVBQVVGLFFBQVMsV0FBVCxDQUFoQjs7QUFFQSxNQUFNRyxVQUFOLENBQWlCO0FBQ2hCQyxhQUFhQyxPQUFiLEVBQXVCO0FBQ3RCLE9BQUtDLE1BQUwsR0FBYyxFQUFkO0FBQ0EsT0FBS0MsU0FBTCxHQUFpQixFQUFqQjtBQUNBLE9BQUtDLEVBQUwsR0FBVVAsTUFBTVEsSUFBTixFQUFWOztBQUVBLE9BQUtDLGFBQUwsR0FBcUJULE1BQU1RLElBQU4sR0FBYUUsU0FBYixDQUF3QixNQUFNO0FBQ2xELFVBQVMsS0FBS0MsT0FBTCxHQUFlLElBQUlWLE9BQUosQ0FBYSxJQUFiLENBQXhCO0FBQ0EsR0FGb0IsQ0FBckI7O0FBSUEsT0FBS1csb0JBQUwsR0FBNEJaLE1BQU1RLElBQU4sR0FBYUUsU0FBYixDQUF3QixNQUFNO0FBQ3pELFVBQVMsS0FBS0MsT0FBTCxHQUFlLElBQUlWLE9BQUosQ0FBYSxJQUFiLENBQXhCO0FBQ0EsR0FGMkIsQ0FBNUI7O0FBSUEsT0FBS1ksS0FBTCxHQUFhYixNQUFNUSxJQUFOLEdBQWFFLFNBQWIsQ0FBd0IsTUFBTTtBQUMxQ047QUFDQSxRQUFLRyxFQUFMLENBQVFPLFFBQVIsQ0FBa0IsT0FBbEIsRUFBNEJDLEtBQTVCO0FBQ0EsR0FIWSxDQUFiO0FBSUE7O0FBRUQ7O0FBRUEsS0FBSUMsY0FBSixHQUFxQjtBQUNwQixTQUFPLEtBQUtMLE9BQVo7QUFDQTs7QUFFRCxLQUFJTSxlQUFKLEdBQXNCO0FBQ3JCLFNBQU8sS0FBS04sT0FBTCxDQUFhTSxlQUFwQjtBQUNBOztBQUVLQyxjQUFOLENBQXFCQyxTQUFyQixFQUFnQ0MsT0FBaEMsRUFBeUNDLFVBQXpDLEVBQXNEO0FBQUE7O0FBQUE7QUFDckQsU0FBTVYsVUFBVSxJQUFJVixPQUFKLE9BQWhCO0FBQ0EsU0FBTVUsUUFBUVcsV0FBUixDQUFxQkgsU0FBckIsRUFBZ0NDLE9BQWhDLEVBQXlDQyxVQUF6QyxDQUFOO0FBRnFEO0FBR3JEOztBQUVLRSxpQkFBTixDQUF3QkMsUUFBeEIsRUFBa0NDLFVBQWxDLEVBQThDTCxPQUE5QyxFQUF1REMsVUFBdkQsRUFBb0U7QUFBQTs7QUFBQTtBQUNuRSxTQUFNVixVQUFVLElBQUlWLE9BQUosUUFBaEI7QUFDQSxTQUFNVSxRQUFRZSxPQUFSLENBQWlCRixRQUFqQixFQUEyQkMsVUFBM0IsRUFBdUNMLE9BQXZDLEVBQWdEQyxVQUFoRCxDQUFOO0FBRm1FO0FBR25FOztBQUVETSxjQUFjLEVBQUVDLFNBQVM5QixFQUFFK0IsUUFBYixFQUF1QkMsZ0JBQWdCaEMsRUFBRWlDLFFBQXpDLEVBQWQsRUFBb0U7QUFDbkUsU0FBTyxLQUFLcEIsT0FBTCxDQUFhTSxlQUFiLENBQ0xXLE1BREssQ0FDR0ksT0FBT0osT0FBUUksR0FBUixDQURWLEVBRUxDLEdBRkssQ0FFQUQsT0FBT0UsT0FBT0MsTUFBUCxDQUFlSCxHQUFmLEVBQW9CLEVBQUVJLE1BQU1OLGNBQWVFLElBQUlaLE9BQW5CLENBQVIsRUFBcEIsQ0FGUCxDQUFQO0FBR0E7QUE1Q2U7O0FBK0NqQmlCLE9BQU9DLE9BQVAsR0FBaUJwQyxVQUFqQiIsImZpbGUiOiJjb25uZWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgXyA9IHJlcXVpcmUoIFwibG9kYXNoXCIgKTtcbmNvbnN0IHNpbm9uID0gcmVxdWlyZSggXCJzaW5vblwiICk7XG5jb25zdCBDaGFubmVsID0gcmVxdWlyZSggXCIuL2NoYW5uZWxcIiApO1xuXG5jbGFzcyBDb25uZWN0aW9uIHtcblx0Y29uc3RydWN0b3IoIG9uQ2xvc2UgKSB7XG5cdFx0dGhpcy5xdWV1ZXMgPSB7fTtcblx0XHR0aGlzLmV4Y2hhbmdlcyA9IHt9O1xuXHRcdHRoaXMub24gPSBzaW5vbi5zdHViKCk7XG5cblx0XHR0aGlzLmNyZWF0ZUNoYW5uZWwgPSBzaW5vbi5zdHViKCkuY2FsbHNGYWtlKCAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzLmNoYW5uZWwgPSBuZXcgQ2hhbm5lbCggdGhpcyApICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5jcmVhdGVDb25maXJtQ2hhbm5lbCA9IHNpbm9uLnN0dWIoKS5jYWxsc0Zha2UoICgpID0+IHtcblx0XHRcdHJldHVybiAoIHRoaXMuY2hhbm5lbCA9IG5ldyBDaGFubmVsKCB0aGlzICkgKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLmNsb3NlID0gc2lub24uc3R1YigpLmNhbGxzRmFrZSggKCkgPT4ge1xuXHRcdFx0b25DbG9zZSgpO1xuXHRcdFx0dGhpcy5vbi53aXRoQXJncyggXCJjbG9zZVwiICkueWllbGQoKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBUZXN0IEhlbHBlcnNcblxuXHRnZXQgY3VycmVudENoYW5uZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhbm5lbDtcblx0fVxuXG5cdGdldCB0cmFja2VkTWVzc2FnZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhbm5lbC50cmFja2VkTWVzc2FnZXM7XG5cdH1cblxuXHRhc3luYyBzZW5kVW50cmFja2VkKCBxdWV1ZU5hbWUsIGNvbnRlbnQsIHByb3BlcnRpZXMgKSB7XG5cdFx0Y29uc3QgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCB0aGlzICk7XG5cdFx0YXdhaXQgY2hhbm5lbC5zZW5kVG9RdWV1ZSggcXVldWVOYW1lLCBjb250ZW50LCBwcm9wZXJ0aWVzICk7XG5cdH1cblxuXHRhc3luYyBwdWJsaXNoVW50cmFja2VkKCBleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgcHJvcGVydGllcyApIHtcblx0XHRjb25zdCBjaGFubmVsID0gbmV3IENoYW5uZWwoIHRoaXMgKTtcblx0XHRhd2FpdCBjaGFubmVsLnB1Ymxpc2goIGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBwcm9wZXJ0aWVzICk7XG5cdH1cblxuXHRnZXRQdWJsaXNoZWQoIHsgZmlsdGVyID0gXy5zdHViVHJ1ZSwgYm9keVRyYW5zZm9ybSA9IF8uaWRlbnRpdHkgfSApIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFubmVsLnRyYWNrZWRNZXNzYWdlc1xuXHRcdFx0LmZpbHRlciggbXNnID0+IGZpbHRlciggbXNnICkgKVxuXHRcdFx0Lm1hcCggbXNnID0+IE9iamVjdC5hc3NpZ24oIG1zZywgeyBib2R5OiBib2R5VHJhbnNmb3JtKCBtc2cuY29udGVudCApIH0gKSApO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbjtcbiJdfQ==